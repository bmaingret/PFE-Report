%
% CITI Research Report Template
%
% 07/2012: Paul Ferrand - Initial Template
% 02/2013: Frederic Le Mouel - Refactoring
% 

\documentclass[a4paper]{article}

%
% Packages
%

\usepackage[utf8]{inputenc}% ou \usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{graphicx}
\usepackage{listings}

\lstset{columns=fullflexible,basicstyle=\ttfamily}

\begin{document}

%
% Cover Page
%

\pagestyle{empty}
\begin{center}
\begin{figure}%
\centering
%\includegraphics[width=0.5\columnwidth]{logo/citi-old-bw.eps}% old logo
%\includegraphics[width=0.4\columnwidth]{logo/citi-new-bw.eps}% new logo 
\includegraphics[width=0.4\columnwidth]{logo/citi-new-title-bw.eps}% old logo - titled
\end{figure}
%{\LARGE \textsc{Communication scientifique}} \\ % in French
{\LARGE \textsc{Scientific Communication}} \\ % in English
\vspace{0.5cm}
%{Centre d'Innovation en Télécommunications et Intégration de Services} \\ % in French
{Center of Innovation in Telecommunications and Integration of Services} \\ % in English
\vspace{2cm}
{\Large \textbf{ConGolo: A Context Oriented language based on Golo}} \\
\vspace{10pt}
{\large \textit{Baptiste Maingret}} \\
\vspace{10pt}
{\large April 2014} \\
\vspace{20pt}
\begin{minipage}{0.8\columnwidth}
\sffamily
\small
INCLUDE ABSTRACT HERE
\end{minipage}
\end{center}
\vfill
\begin{minipage}[b]{0.3\columnwidth}
\includegraphics[width=\columnwidth]{logo/inria.eps}%
\end{minipage}
\hfill
\begin{minipage}{0.3\columnwidth}
\small
\centering
\textbf{
%Université de Lyon \\ % in French
University of Lyon \\ % in English
%INSA de Lyon \\ % in French
INSA Lyon \\ % in English
INRIA \\
Shanghai Jiao Tong University
}
\end{minipage}
\hfill
\begin{minipage}[b]{0.25\columnwidth}
\includegraphics[width=\columnwidth]{logo/insa-noir.eps}%
\end{minipage}

\newpage

%
% Title page
%

\title{Research Report}

\author{Baptiste Maingret\\[10pt]
INSA-Lyon, F-69621, Villeurbanne, France\\
\texttt{baptiste.maingret@insa-lyon.fr}}

\date{\today}
\newcommand{\Keywords}[1]{\par\noindent 
{\small{\em Keywords\/}: #1}}
\maketitle

\begin{abstract} 
Insert abstract here
\Keywords{Context-Oriented Programming, Golo, Java, System reasoning, Dynamic Language}
\end{abstract}

\newpage

%
% Report Body
%

\section{Introduction}


\section{Contribution}

\section{Results}

\section{State of the Art}

\subsection{Context-Oriented Programming}

What is COP???

There are already many COP languages based on a variety of languages. In order to classify and compare those, and to locate our contributions, we will compare the different approaches on three aspects:
\begin{itemize}
  \item the context management or how to define context-specific behaviours
  \item the handling of context changes
  \item the type of system reasoning or decision making algorithm.
\end{itemize}

We will also indicate their performance level when they are available.

ContextJ* \cite{appeltauer_dedicated_2008} was designed using the Java programming language. Their implementation allow describing and activating behaviour dependent actions. The definition is made using layers that encapsulates partial method declarations. Those layers are embedded in the source code of the application and are activated according to the current context at run-time. Thus the decision making process is of type Event-Condition-Action (ECA). These functionalities were implemented as a Java library using LogicAJ \cite{}. The layered method are identified by their first argument being a subtype of Layer. The  with construct is done through the use of two methods, \lstinline|activateLayer(Layer)| and \lstinline|deactivateLayer(Layer)|. Thus the activation of layers is embedded in the base source code. This proof-of-concept was then further developed as a full feature language based on Java called ContextJ \cite{haupt_contextj:_2011} \cite{appeltauer_improving_2009}. They introduce  the almost standard \lstinline|with/without| block statement as well as several other symbol (layer, proceed, before and after) and provide a reflection API for layer reasoning. The benchmarks show that the overhead introduced by the layers in regards with basic method calls is significant.

EventCJ \cite{kamina_eventcj:_2011} offers a different approach based on events for the transitions of layers. The definition of the context-dependent behaviours is based on the same principles as ContextJ described above (layers and partial methods). The implementation is also different since EventJ is designed as en extension of the Java language with its own compiler. The decision making process is an ECA except for the transition between layers which is designed as an automate defined using transition rules between layers.


JCop \cite{appeltauer_declarative_2013} is following on from ContextJ. They better improve it by introducing layer inheritance, global layers and cross-cutting layer compositions. The context is encapsulated in context classes which are defined by the use of a new keyword \lstinline|contextclass|. These classes encapsulate the layer composition and the pointcuts and advices using classic keywords (on, when, with, without and withoutall). The reasoning in done by an ECA approach.

ContextFJ \cite{clarke_semantics_2009} extends Featherweight Java \cite{} to implement COP. They use layers and introduce new keywords to that extend.

Events seems as used in \cite{kamina_eventcj:_2011} allow for a good modularity and an asynchronous handling of the context variations. EventJava \cite{jayaram_context-oriented_2009} is a Java language framework that offers an asynchronous event management system, with a compiler based on Polyglot. Context is represented simply by a class whose attributes define the current context. The same class is used throughout the application. Events' attributes are initialized with the information specified in the context class. The matching process is done using the Rete algorithm \cite{}, but this can be changed as for context, substract which are defined as API. Thus the reasoning system to how react to different events can be done in different manner.

As pointed out by \cite{nunez_declarative_2009}, context-dependent behaviours may occurs in two distinct manners. First, the reaction to events may depend on the current context. Second, context changes can be seen as event and thus be reacted to. ECaesarJ \cite{nunez_declarative_2009} proposes a COP language based on events where context is implemented by extending an abstract class and events are defined with specific keywords. It is designed such that the context are activated and deactivated by the mean of events and the state of the context is stored in a boolean attribute. The behaviour-dependent actions are then implemented in classes that can bind context activation events with their own events and actions. The reasoning is thus done using an ECA approach. They offer more advanced options such as implicit events which are triggered on identified method calls, list quantification so that any objects from a list can triggering a specific event will trigger a global event and context composition.

\cite{bainomugisha_towards_2009} proposes a solution to deal with the selection of context-dependent behaviour when possible conflict between contexts could appear especially in the case of dependencies between context.  The decisions are made using a propagator model.




+ context management: how to define context-specific behaviors? Second, it may be important to react to context changes.
  expression of the context
  implementation of context dependent actions
  scope of the context (per thread/object instance)

+ context change notifications

+ reasoning/smartness: ECA/Neural networks
abstraction of this part


+ performances
  Versus common implementation or ...
  

\section{Conclusion \& Perspectives}

%
% Bibliography
%

\bibliographystyle{alpha}
\bibliography{RR_CITI}


\end{document}

