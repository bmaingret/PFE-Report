%
% CITI Research Report Template
%
% 07/2012: Paul Ferrand - Initial Template
% 02/2013: Frederic Le Mouel - Refactoring
% 

\documentclass[a4paper]{article}

%
% Packages
%

\usepackage[utf8]{inputenc}% ou \usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{graphicx}
\usepackage{listings}
\usepackage[bookmarks]{hyperref}

\lstset{columns=fullflexible,basicstyle=\ttfamily}

\begin{document}

%
% Cover Page
%

\pagestyle{empty}
\begin{center}
\begin{figure}%
\centering
%\includegraphics[width=0.5\columnwidth]{logo/citi-old-bw.eps}% old logo
%\includegraphics[width=0.4\columnwidth]{logo/citi-new-bw.eps}% new logo 
\includegraphics[width=0.4\columnwidth]{logo/citi-new-title-bw.eps}% old logo - titled
\end{figure}
%{\LARGE \textsc{Communication scientifique}} \\ % in French
{\LARGE \textsc{Scientific Communication}} \\ % in English
\vspace{0.5cm}
%{Centre d'Innovation en Télécommunications et Intégration de Services} \\ % in French
{Center of Innovation in Telecommunications and Integration of Services} \\ % in English
\vspace{2cm}
{\Large \textbf{ConGolo: A Context Oriented language based on Golo}} \\
\vspace{10pt}
{\large \textit{Baptiste Maingret}} \\
\vspace{10pt}
{\large April 2014} \\
\vspace{20pt}
\begin{minipage}{0.8\columnwidth}
\sffamily
\small
INCLUDE ABSTRACT HERE
\end{minipage}
\end{center}
\vfill
\begin{minipage}[b]{0.3\columnwidth}
\includegraphics[width=\columnwidth]{logo/inria.eps}%
\end{minipage}
\hfill
\begin{minipage}{0.3\columnwidth}
\small
\centering
\textbf{
%Université de Lyon \\ % in French
University of Lyon \\ % in English
%INSA de Lyon \\ % in French
INSA Lyon \\ % in English
INRIA \\
Shanghai Jiao Tong University
}
\end{minipage}
\hfill
\begin{minipage}[b]{0.25\columnwidth}
\includegraphics[width=\columnwidth]{logo/insa-noir.eps}%
\end{minipage}

\newpage

%
% Title page
%

\title{Research Report}

\author{Baptiste Maingret\\[10pt]
INSA-Lyon, F-69621, Villeurbanne, France\\
\texttt{baptiste.maingret@insa-lyon.fr}}

\date{\today}
\newcommand{\Keywords}[1]{\par\noindent 
{\small{\em Keywords\/}: Context-Oriented Programming, Golo, Java, System reasoning, Dynamic Language}}
\maketitle

\begin{abstract} 
Insert abstract here
\Keywords{Context-Oriented Programming, Golo, Java, System reasoning, Dynamic Language}
\end{abstract}

\newpage

%
% Report Body
%

\section{Introduction}
what is cop
trends

internet of things and cop: how they are related

what is golo \cite{ponge_golo_2013}

\section{State of the Art}

\subsection{Context-Oriented Programming}


There are already many COP languages based on a variety of languages. Most of them implements the context with the use of layers. In order to compare these languages wi can thus focus at first on the way the layer are handled, i.e. their declaration and activation \cite{appeltauer_comparison_2009}.

Two strategies are often found: layer-in-class and class-in-layer implementation. The first is used in \cite{appeltauer_declarative_2012} \cite{appeltauer_dedicated_2008} \cite{appeltauer_improving_2009} \cite{kamina_eventcj:_2011} \cite{nunez_declarative_2009}. The later is found in \cite{lincke_open_2011} [citations needed]. Some languages as ContextL provide both models and \cite{ghezzi_context_2010} which focuses on distributed COP asserts that the best solution for layer declaration is an hybrid technique between layer-in-class and class-in-layer models. 

The activation of layers often use the keyword \lstinline|with| \cite{haupt_contextj:_2011} \cite{appeltauer_declarative_2013} \cite{}.

Implementation

In order to classify and compare those, and to locate our contributions, we will compare the different approaches on three aspects:
\begin{itemize}
  \item the context management or how to define context-specific behaviours
  \item the handling of context changes
  \item the type of system reasoning or decision making algorithm.
\end{itemize}

We will also indicate their performance level when they are available.

ContextJ* \cite{appeltauer_dedicated_2008} was designed using the Java programming language. Their implementation allow describing and activating behaviour dependent actions. The definition is made using layers that encapsulates partial method declarations. Those layers are embedded in the source code of the application and are activated according to the current context at run-time. Thus the decision making process is of type Event-Condition-Action (ECA). These functionalities were implemented as a Java library using LogicAJ \cite{}. The layered method are identified by their first argument being a subtype of Layer. The  with construct is done through the use of two methods, \lstinline|activateLayer(Layer)| and \lstinline|deactivateLayer(Layer)|. Thus the activation of layers is embedded in the base source code. This proof-of-concept was then further developed as a full feature language based on Java called ContextJ \cite{haupt_contextj:_2011} \cite{appeltauer_improving_2009}. They introduce  the almost standard \lstinline|with/without| block statement as well as several other symbol (layer, proceed, before and after) and provide a reflection API for layer reasoning. The benchmarks show that the overhead introduced by the layers in regards with basic method calls is significant.

JCop \cite{appeltauer_declarative_2013} is following on from ContextJ. They better improve it by introducing layer inheritance, global layers and cross-cutting layer compositions. The context is encapsulated in context classes which are defined by the use of a new keyword \lstinline|contextclass|. These classes encapsulate the layer composition and the pointcuts and advices using classic keywords (on, when, with, without and withoutall). The reasoning in done by an ECA approach.

EventCJ \cite{kamina_eventcj:_2011} offers a different approach based on events for the transitions of layers. The definition of the context-dependent behaviours is based on the same principles as ContextJ described above (layers and partial methods). The implementation is also different since EventCJ is designed as en extension of the Java language with its own compiler. The decision making process is an ECA except for the transition between layers which is designed as an automate defined using transition rules between layers.

ContextFJ \cite{clarke_semantics_2009} extends Featherweight Java \cite{} to implement COP. They use layers and introduce new keywords to that extend.

Events as used in \cite{kamina_eventcj:_2011} allow for a good modularity and an asynchronous handling of the context variations. EventJava \cite{jayaram_context-oriented_2009} is a Java language framework that offers an asynchronous event management system, with a compiler based on Polyglot. Context is represented simply by a class whose attributes define the current context. The same class is used throughout the application. Events' attributes are initialized with the information specified in the context class. The matching process is done using the Rete algorithm \cite{}, but this can be changed as for context, substract which are defined as API. Thus the reasoning system to how react to different events can be done in different manner.

As pointed out by \cite{nunez_declarative_2009}, context-dependent behaviours may occurs in two distinct manners. First, the reaction to events may depend on the current context. Second, context changes can be seen as event and thus be reacted to. ECaesarJ \cite{nunez_declarative_2009} proposes a COP language based on events where context is implemented by extending an abstract class and events are defined with specific keywords. It is designed such that the context are activated and deactivated by the mean of events and the state of the context is stored in a boolean attribute. The behaviour-dependent actions are then implemented in classes that can bind context activation events with their own events and actions. The reasoning is thus done using an ECA approach. They offer more advanced options such as implicit events which are triggered on identified method calls, list quantification so that any objects from a list can triggering a specific event will trigger a global event and context composition.

\cite{bainomugisha_towards_2009} proposes a solution to deal with the selection of context-dependent behaviour when possible conflict between contexts could appear especially in the case of dependencies between context.  The decisions are made using a propagator model.

NextEJ \cite{kamina_towards_2009} is a COP language based on EpsilonJ \cite{}. In addition to context it introduces the notion of roles. The contexts and roles are represented using classes defined by the specific keywords \lstinline|context| and \lstinline|role|. The activation of layers, or contexts, are explicitly activated at run-time with the keyword \lstinline|bind|. Their is no explicit reasoning system but only the one the developers chose to implement.

In \cite{appeltauer_layered_2010} the authors explores the use of the new INVOKEDYNAMIC (ID) instruction introduced in Java 7 which allows for dynamic method dispatch to implement the layer method dispatch in JCOP \cite{appeltauer_declarative_2013}. The performances shown are encouraging especially since at the time of writing the implementation of in the JVM was not yet over. Thus the Golo language, based on ID form day one, could be a good applicant for COP languages.

\cite{gonzalez_transactional_2009} cop and reflection to adapt language semantics. Based on an example of transactional system where they use context as transaction

\cite{clarke_how_2009} points out a specific problem when using multiple layers composition, using the \lstinline|proceed| keyword to call previous activated layer, and closure which change the environment. For COP language solely based on Java this is not a problem since it does not implement closures, but as for this project, Golo implements closures and thus it should be taken into account. 

ContextLua \cite{wasty_contextlua:_2010} is an extension to the language Lua for COP defined with Metalua. The definition of the context is done with the help of layers and their activation uses the keyword \lstinline|with|. The context-dependent behaviours are implemented by partial methods whose name contains the layer for which they should be used. They also implement the \lstinline|proceed| method to allow for layer composition. They do not provide performance evaluation but it is noted that the amount of added code is relatively small.

ContextErlang \cite{ghezzi_context_2010} is a COP version of Erlang that support the agent paradigm using message-based concurrent. As for EventCJ \cite{kamina_eventcj:_2011} the use of events, or messages, is used which separates the context management of the behaviours-dependent actions.  \cite{ghezzi_context_2010} also asserts that the best solution for layer declaration is an hybrid technique between layer-in-class and class-in-layer models.

\cite{schippers_graph-based_2010} use graph to manage contexts

 
\section{Contribution}

\section{Results}

Perfomance evaluation
10 methods layered and plain implementation as in \cite{appeltauer_comparison_2009} where multiple languages were tested to create a benchmark, similar to \cite{kamina_eventcj:_2011}.

\section{Conclusion \& Perspectives}

%
% Bibliography
%

\bibliographystyle{plain}
\bibliography{RR_CITI}


\end{document}

