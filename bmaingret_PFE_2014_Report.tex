%
% CITI Research Report Template
%
% 07/2012: Paul Ferrand - Initial Template
% 02/2013: Frederic Le Mouel - Refactoring
% 

\documentclass[a4paper]{article}

%
  
\usepackage{pdflscape}
\usepackage{multirow}
\usepackage[utf8]{inputenc}% ou \usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{graphicx}
\usepackage{listings}
\usepackage[bookmarks]{hyperref}
\usepackage{caption}
\usepackage{adjustbox}

\lstset{numbers=left, numberstyle=\small, numbersep=8pt, frame = single, framexleftmargin=15pt, columns=fullflexible,basicstyle=\ttfamily, breaklines=true}

\begin{document}

%
% Cover Page
%

\pagestyle{empty}
\begin{center}
\begin{figure}%
\centering
%\includegraphics[width=0.5\columnwidth]{logo/citi-old-bw.eps}% old logo
%\includegraphics[width=0.4\columnwidth]{logo/citi-new-bw.eps}% new logo 
\includegraphics[width=0.4\columnwidth]{logo/citi-new-title-bw.eps}% old logo - titled
\end{figure}
%{\LARGE \textsc{Communication scientifique}} \\ % in French
{\LARGE \textsc{Scientific Communication}} \\ % in English
\vspace{0.5cm}
%{Centre d'Innovation en Télécommunications et Intégration de Services} \\ % in French
{Center of Innovation in Telecommunications and Integration of Services} \\ % in English
\vspace{2cm}
{\Large \textbf{ConGolo: A Context-oriented language based on Golo}} \\
\vspace{10pt}
{\large \textit{Baptiste Maingret}} \\
\vspace{10pt}
{\large April 2014} \\
\vspace{20pt}
\begin{minipage}{0.8\columnwidth}
\sffamily
\small
INCLUDE ABSTRACT HERE
\end{minipage}
\end{center}
\vfill
\begin{minipage}[b]{0.3\columnwidth}
\includegraphics[width=\columnwidth]{logo/inria.eps}%
\end{minipage}
\hfill
\begin{minipage}{0.3\columnwidth}
\small
\centering
\textbf{
%University of Lyon \\ % in English
INSA Lyon \\ % in English
Shanghai Jiao Tong University
}
\end{minipage}
\hfill
\begin{minipage}[b]{0.25\columnwidth}
\includegraphics[width=\columnwidth]{logo/insa-noir.eps}%
\end{minipage}

\newpage

%
% Title page
%

\title{Research Report}

\author{Baptiste Maingret\\[10pt]
INSA-Lyon, F-69621, Villeurbanne, France\\
\texttt{baptiste.maingret@insa-lyon.fr}}

\date{\today}
\newcommand{\Keywords}[1]{\par\noindent 
{\small{\em Keywords\/}: Context-Oriented Programming, Golo, Java, System reasoning, Dynamic Language}}
\maketitle

\begin{abstract} 
Insert abstract here
\Keywords{Context-Oriented Programming, Golo, Java, System reasoning, Dynamic Language}
\end{abstract}

\newpage

%
% Report Body
%

\section{Introduction}

Internet of Things (IoT) takes a lot attention nowadays because of its implication in our daily lives, in many different markets and because of unique requirements in research. Protocols have emerged to make the IoT a reality but today trend is to standardize the way IoT can be used to allow its further development and ease of interconnection with existing infrastructures. Thus the Web of Things is also taking interest among the research community. However software development for IoT has not seen many improvements nor evolution to cope with the new specificities of IoT. 

In parallel context-oriented programming (COP) has drawn research interest in the past years. Several new COP languages have emerged. Most of these approaches allow for multiple contexts definition and their activations. They also allow the developer to specify context-dependent behaviours. Because of the dynamism of the IoT, COP could be a good option for the development of IoT applications.

In addition, none of the current COP work seems to focus on the decision-making systems backing up these COP languages. Whereas it is to decide what context should be activated or what actions should be done based on the current context, current systems only allow for one implementation and does not provide any sort of abstraction. Systems are often simple event-condition-action (ECA) process which do not leverage the full potential of the IoT. More advanced systems such as neural networks, genetic algorithms, Petri networks could be used.


May languages have seen their COP counterparts born. Several approaches were based on Java and the JVM. Because of its high development in embedded system, the JVM seems to be a good candidate for the development of IoT applications. In addition, dynamic languages for the JVM have been created such as Groovy or Golo \cite{ponge_golo_2013}. Golo is a lightweight dynamic JVM language built with invokedynamic.

In this paper, we propose a new COP language ConGolo, extending the Golo language, that will allow abstracting the reasoning mechanisms whether it is a simple event-condition-action (ECA), a automate, a neural network or yet another approach, and we will propose a use-case based on a WoT application.


In section \ref{section:stateoftheart} we will first see the different approaches taken by existing COP languages to explain the choices made in ConGolo. In \ref{section:contribution} we will present Congolo and the abstraction mechanism for decision-making and reasoning systems. In \ref{section:implementation} we will describe the implementation and discuss the choices made.



\section{State of the Art: Context-Oriented Programming}
\label{section:stateoftheart}

\paragraph{Context-Oriented Programming}
There are already many COP languages based on a variety of languages. Most of them implements the context with the use of layers which acts as a context and context-dependent behaviours definition but some others also explicitly separate the two. In order to compare these languages we can thus focus at first on the way the context are defined, then how they are activated and finally how they are used throughout the code. A summary table \ref{table:coplanguages}, inspired by \cite{appeltauer_comparison_2009}, is proposed.

In many languages, context is integrated directly in the business code by the mean of layers. It is the case in JCop \cite{appeltauer_declarative_2012}, as in listing \ref{listing:jcoplayer}, ContextJ \cite{appeltauer_dedicated_2008} \cite{appeltauer_improving_2009}, ContextErlang \cite{ghezzi_context_2010}, ContextLua \cite{wasty_contextlua:_2010} or EventCJ \cite{kamina_eventcj:_2011}. In ECaesarJ \cite{nunez_declarative_2009}, NextEJ \cite{kamina_towards_2009} or Javanese \cite{kamina_unified_2013} the contexts are declared separately as in listings \ref{listing:ecaesarjcontext}, \ref{listing:javanesecontext} and \ref{listing:nextejcontext}. In EventJava \cite{jayaram_context-oriented_2009}, context is considered to be an event with specific data, listing \ref{listing:eventjavacontext} and is defined alongside the event consumer. Thus when the event arrives, the context is embedded into it.

\begin{lstlisting}[float, language=Java, caption=JCop layer example, label={listing:jcoplayer}]
public class Hero {
  public Point getPosition() {...} //plain meth.
  public void move(Direction dir) {...} //base meth. for layered method Hero.move
  private Position getPos() {...} //base meth. for layered method Hero.getPos
  
  layer ConfusedHeroLayer { //layer extension declaration
    private Position getPos() {...} //partial meth. for layered method Hero.getPos
  }

  public layer ConfusedHeroLayer { //(top-level) layer declaration
    public void Hero.move(Direction dir) { //partial meth. for layerd meth. Hero.move
      proceed(dir); //a proceed expression
    }
    private Direction getNewDir(Direction original) {...} //layer local method
  }
}
\end{lstlisting}

\begin{lstlisting}[float, language=Java, caption=ECaesarJ context declaration, label={listing:ecaesarjcontext}]
cclass ScheduledNightTime extends Context {
  TimeService sunset, sunrise;
  event in() = sunset.time();
  event out() = execution(* *.openBinds(..));
  // or
  //  event out() = sensor.intensityChanged(int i) && if (isActive() && i > threshold);
}
\end{lstlisting}

\begin{lstlisting}[float, language=Java, caption=Javanese context declaration, label={listing:javanesecontext}]
// Contexts declaration
context GPSon
  active(int s) :after call(void Nav.onStatusChanged(*)) && args(s)
      && if(GPS.AVAILABLE==s)
  until(int s) :after call(void Nav.onStatusChanged(*)) && args(s)
      && if(GPS.AVAILABLE!=s);
      
context RouteSearching
  // context active during the execution of the specified method
  cflow(call(void Nav.calcRoute()));
\end{lstlisting}

\begin{lstlisting}[float, language=Java, caption=NextEJ context declaration, label={listing:nextejcontext}]
context Building {
  role Guest {
    void escape() { .. }
  }
  role Security {
    void notify() {
      Guest.escape();
    }
  }
}
\end{lstlisting}

\begin{lstlisting}[float, language=Java, caption=EventJava context declaration, label={listing:eventjavacontext}]
public class Context implements Comparable<Context>, Serializable {
  public long time;
  ... /* more fields */
  public Context() { time = System.currentTimeMillis(); }
  public Context(long time) { this.time = time; }
  public int compare(Context other) {
    if(timestamp == other.timestamp) return 0;
    ...
  }
  ...
}
\end{lstlisting}

EventJava 

 
The activation of the context, or layers depending on the language, often use the keyword \lstinline|with| \cite{haupt_contextj:_2011} \cite{appeltauer_declarative_2013} \cite{kamina_towards_2009} \cite{wasty_contextlua:_2010} as shown in the listing \ref{listing:jcopwith}. Instead \cite{ghezzi_context_2010}, \cite{nunez_declarative_2009} or \cite{kamina_eventcj:_2011} use a different approach where contexts are activated independently of the running program by the mean of events. In \cite{nunez_declarative_2009}, the activation is done by the use of specific events declared in the context object which can be triggered by others events, by method invocation or by composite expression as in listing \ref{listing:ecaesarjcontext}. In \cite{kamina_eventcj:_2011}, they declare transition rules based on events that will activate or deactivate contexts, as in listing \ref{listing:eventcjevent}. In \cite{kamina_unified_2013}, where the distinction is made between context and layers, the context state is changed by specific actions and thus can be activate in the program, whereas layers are activated according to the state of one or multiple contexts and thus are activated implicitly, as in listing \ref{listing:javanesecontext}. Finally, in EventJava, where the context is defined by specific values of information when the event is triggered, the activation of the context is global but its particular definition, i.e. the values of the information that it holds, are defined by events.

 
\begin{lstlisting}[float, language=Java, caption=JCop layer activation, label={listing:jcopwith}]
public void moveHeroLeft() {
	with (new ConfusedHeroLayer(), new RainLayer()) {
    getHero().move(Direction.LEFT); }
}
\end{lstlisting}

\begin{lstlisting}[float, language=Java, caption=EventCJ layer activation, label={listing:eventcjevent}]
direction SwitchPositioningDevice {
  declare event GPSEvent(Navigation n, int s)
    :after call(void Navigation.onStatusChanged(s))
      &&target(n)&&args(s)
      &&if(s==LocationProvider.AVAILABLE)
    :sendTo(n);
  declare event WifiEvent(Navigation n, int s)
    :after call(void Navigation.onStatusChanged(s))
      &&target(n)&&args(s)
      &&if(s==LocationProvider.OUT_OF_SERVICE)
    :sendTo(n);
  declare event Boarding()
    :after call(void *.cabinModeEntered());
  declare event Arriving()
    :after call(void *.cabinModeExit());
  
  transition GPSEvent:
    WifiNavi switchTo GPSNavi | not OnBoard activate GPSNavi;
  transition WifiEvent:
    GPSNavi switchTo WifiNavi | not OnBoard activate WifiNavi;
  transition Boarding:
    * switchTo OnBoard;
  transition Arriving:
    OnBoard switchTo .;
}
\end{lstlisting}

\begin{lstlisting}[float, language=Java, caption=Javanese context declaration, label={listing:javaneselayer}]
// Layers declaration
activate Outdoors when GPSon && StrongGPS;
activate Indoors when !GPSon || !StrongGPS;
\end{lstlisting}


ContextJ JCop EventCJ NextEJ ContextLua ContextErlang EventJava Javanese ECaesarJ 

Two strategies are often found: layer-in-class and class-in-layer implementation.
The later is found in ContextJS \cite{lincke_open_2011}. Some languages as ContextL provide both models and the authors of ContextErlang \cite{ghezzi_context_2010} which focuses on distributed COP assert that the best solution for layer declaration is an hybrid technique between layer-in-class and class-in-layer models.

The layers and corresponding behaviours are implemented inside the class such as in \ref{listing:jcoplayer}.
NextEJ the latter
Finally, we need to consider how the rest of the program takes into account the different contexts to adapt and modify the program. \cite{appeltauer_declarative_2013} \cite{kamina_eventcj:_2011} do the same \ref{listing:jcoplayer} \ref{listing:eventcjlayeruse}
ECaesarJ offers two distinct ways of using the current context. First, it is possible to bind specific events to the events triggered by the context changes as in listing \ref{listing:ecaesarjcontextuse} or to directly query the context state with the help of the method \lstinline|isActive()| of the context.

\begin{lstlisting}[float, language=Java, caption=ECaesarJ context use, label={listing:ecaesarjcontextuse}]
cclass LightAutomation {
  ILight light;
  Context context;

  event mustTurnOn() = context.in();
  event mustTurnOff() = context.out();

  mustTurnOn() => { light.switchOn(); }
  mustTurnOff() => { light.switchOff(); }
}
\end{lstlisting}

\begin{lstlisting}[float, language=Java, caption=EventCJ context-dependent behaviour, label={listing:eventcjlayeruse}]
class Navigation extends MapActivity implements Runnable, LocationListener {
  MapView mapView;
  MyLocationOverlay overlay;
    
  void onStatusChanged(...) {...}
  void run() {}
  void onCreate(Bundle status) {
    ...
    overlay.runOnFirstFix(this);
    ...
  }
  
  layer GPSNavi {
    activate {
      overlay.onProviderEnabled("gps"); }
    deactivate {
      overlay.onProviderDisabled("gps"); }
    after void run() {
      Location loc = overlay.getMyLocation();
      mapView.getController().animateTo(loc);
  }
}
\end{lstlisting}

There exist different type of implementation for COP languages. The easiest one might be to develop an API such as \cite{appeltauer_dedicated_2008}. One can also extends existing languages with new keywords such as in \cite{clarke_semantics_2009}, ContextJ \cite{haupt_contextj:_2011}, JCOP \cite{appeltauer_declarative_2013}, NextEJ \cite{kamina_towards_2009} or \cite{ghezzi_context_2010}. Finally some papers propose a new COP language as  EventCJ \cite{kamina_eventcj:_2011} or \cite{kamina_unified_2013}.

\begin{landscape}
  \begin{table}
  \begin{adjustbox}{center}
  \begin{tabular}{l p{3cm} c c c c c c c c c c}
  \hline
  \multicolumn{2}{l}{Languages} & ContextJ & JCop & EventCJ & NextEJ & ContextLua & ContextErlang & EventJava & Javanese & ECaesarJ \\
  \hline
  \multirow{2}{*}{Context declaration} & Layer & & & & & & & & & \\
    & Class & & & & & & & & & \\
  \hline  
  \multirow{2}{*}{Layer declaration} & Layer-in-class & X & X & X & & & X & X & X & X \\
    & Class-in-layer & & & & X & & X & & \\
  \hline
  \multirow{2}{*}{Layer implementation} & Class & & & & & & & & X & X \\
    & Layer type & X & X & X & X & X & & & X & \\    
  \hline  
  \multirow{3}{*}{Scope} & Instance & & & X & & X & & X & X & X \\
    & Thread & X & X & & & & & X & X \\
    & Global & & & & & & X & X & X \\
  \hline
  \multicolumn{2}{l}{Events/messages supported} & & & X & & & & X & X & X \\
  \hline
  \multirow{2}{*}{Active context tracking} & Push to layer stack & X & X & X & & & X & X & X & \\
    & Directly change method lookup & & & & & & & X & & \\
  \hline    
  \multirow{3}{*}{Implementation} & Language extension & X & X & & & X & X & X & X & \\
    & New language & & & X & & & & & X & \\
  \end{tabular}
  \end{adjustbox}
  \caption{COP languages comparison}
  \label{table:coplanguages}

  \end{table}
\end{landscape}




\paragraph{Decision-making systems}
Decision making is the process of outputing a final choice based on inputs, that could result in an action. There exist several approaches such as neural networks, genetic algorithms, Petri networks, automates, event-condition-action (ECA).

ECA allow the implementation of rules in an event-driven infrastructure. This is the kind of systems used in most if not all COP languages cited above. It is to be noted that \cite{jayaram_context-oriented_2009} used Rete's algorithm for the rule matching. ECA is composed of events that will triggers the rules, conditions to be checked before executing the rules and finally an action to perform that could be an invocation of a method or an update of local data. Some languages were specifically designed to express such rules as \cite{alferes_event-condition-action_2006}.

State transition systems is another  way of dealing with decision making. A set of states is established and the transitions between each of them are defined. The transitions could be based on events or triggered programatically. The system should also be initialized in order to define the starting state.

Petri net is a modelling languages used to described (distributed) systems but which also can be used for decision making. As with state transition systems, Petri net defined states, transitions and as with ECA some conditions or places. A Petri net should be initialized with a marking defining the number of tokens if in each place. The systems can be triggered by external events or just run internally. There were used in \cite{cardozo_uniting_2012} to manage the context activation and deactivation.

Neural networks were inspired by animal brains and nervous systems. They usually are designed with multiples neurones interconnected into a specific way. The system can then compute outputs based on inputs. To initialize the system one must input specific values for each neurone, which is usually done by a machine learning process. This system is also characterized by a certain precision of the output which usually depends on the learning process.

Genetic algorithms are based on the natrual selection process and are usually used for optimization or problem solvings. As for neural networks, there has to be an initialization which consists of a selection process from a starting population which evolves by using genetic operators, such as mutations or crossovers. Again as for neural networks, the ending precision of the algorith depends on this initialization process.


From an implementation point of view, there exist languages which are often used for artificial intelligence development and thus tend to be used to design decision making systems. Such languages include Lisp and its derivatives and Prolog \cite{lohmann_aspect-oriented_2008}. However none of them include context-oriented functionnalities and there does not seem any extension for COP to exist even if aspect oriented have researched using Prolog. In addition to these dedicated languages, there exist AI frameworks such as the Encog Machine Learning Framework which implements a wide variety of AI process but they still do not allw for an abstraction regarding the type of algorithm to be used.

 
\section{Contribution}
\label{section:contribution}

In this paper we propose a new COP language, namely ConGolo, based on Golo language. We offer basic COP solutions based on previous paper and existing solutions and introduced a new way to abstract the decision making process.

Develop COP

Develop 


\section{Implementation}
\label{section:implementation}

\section{Results}
\label{section:results}

Perfomance evaluation
10 methods layered and plain implementation as in \cite{appeltauer_comparison_2009} where multiple languages were tested to create a benchmark, similar to \cite{kamina_eventcj:_2011}.

Evaluation of COP languages and approaches are usually based on the runtime overhead or the ease of programming. The first implementation of ContextJ \cite{haupt_contextj:_2011} shown a significant overhead when using layers. In \cite{appeltauer_layered_2010} the authors explores the use of the new INVOKEDYNAMIC (ID) instruction introduced in Java 7 which allows for dynamic method dispatch to implement the layer method dispatch in JCOP \cite{appeltauer_declarative_2013}. The performances shown are encouraging especially since at the time of writing the implementation of in the JVM was not yet over. Thus the Golo language, based on ID form day one, could be a good applicant for COP languages. Regarding the other approach of evaluation which would be the ease of programming, including code duplication and code overhead, \cite{appeltauer_declarative_2013} compare JCOP to the previous ContextJ and notice a significant reduction of code due to layer inheritance mechanism and context classes to better compose layers.

\section{Conclusion \& Perspectives}
\label{section:conclusion}


%
% Bibliography
%

\bibliographystyle{plain}
\bibliography{bmaingret_PFE_2014_Report}


\end{document}

